# Quickstart - OpenSSL Camellia-128 Example

_This page will walk you through the basics of using Microsurf with an applied example, testing for side
channel vulnerabilities in OpenSSL's Camellia-128 implementation._

```{note}
Make sure you [installed](installation.md) the framework if you wish to follow along.
```

In the general case, testing a target binary for side channels requires a number of items which are highly dependent on the binary, these include:

- The arguments to be passed to the binary
- Which input is considered to be secret
- How to generate secret inputs

As a user of the `microsurf` library, you have to specify these items. Fortunately, doing so is straightforward.
The general workflow is as follows:

1. Create a new `BinaryLoader` instance, this will allow you to configure general settings relating to the target binary:

```{eval-rst}
.. autoclass:: microsurf.SCDetector.BinaryLoader

```

Most optional arguments can be left as is, we'll dive into more details later on. Let's see how you would use the 
`BinaryLoader` class if you would like to test the OpenSSL implementation of _Camellia-128_.

```{note}
A full working example can be found [here](examples/openssl-camellia-128.py).
```

## Emulation root directory (`rootfs` argument)

For dynamic binaries you will have to provide a root directory (the `rootfs` argument), in which the binary will be emulated. The structure of the directory might look as follows:

```
jail-openssl-x8632/
  lib/
    ld-linux.so.2
    libc.so.6
    libcrypto.so.1.1
    libssl.so.1.1
  input.bin
  openssl
```

```{note}
As a user of the framework, you have to ensure that all required shared objects are present in the correct location. Also create make sure that any input files your binary expects are present. For dynamic x86 binaries you can check which shared objects are expected to be where by running `ldd mybinary.bin`.
```

```{hint}
If a particular shared library is not found in the emulation root, microsurf will issue a warning with the name
of the concerned library.
```


## Specifying arguments (`args` argument)

If we want to encrypt a file `input.bin` using Camellia-128, we would run

```bash
openssl camellia-128-ecb -e -in input.bin -out output.bin -nosalt -K hexdata
```

where `hexdata` would be a 128bit hexadecimal key (for example: `96d496ea1378bf4f6e1f377606013e25`).

In the command above, the data we pass to the `-K` argument is secret. We can signal this to the microsurf framework by replacing the key with an '@' character:

```python
opensslArgs = [
        "camellia-128-ecb",
        "-e",
        "-in",
        "input.bin",
        "-out",
        "output.bin",
        "-nosalt",
        "-K",
        "@",
    ]
scd = SCDetector(
        ...
        args=opensslArgs
        ...
    )
```

The '@' will be replaced with the data produced by the `randGen` function. If `isFile` is true, then the framework will assume that the target binary loads the secret from a file. In that case it will replace the '@' with the path to a temporary file, whose content is generated by the `randGen` function.

You can also mark partial arrguments as secret dependent, for example in the [mbedTLS aes driver program](https://github.com/Mbed-TLS/mbedtls/blob/development/programs/aes/crypt_and_hash.c), the expected arguments are:

```bash
./crypt_and_hash 0 input.bin output.bin AES-128-ECB SHA512 hex:5e1defa4a22621eca5ab3ec051feb3a8
```

In that case, the argument list to pass to microsurf would be:

```python
args = [
        "0",
        "input.bin",
        "output.bin",
        "AES-128-ECB",
        "SHA512",
        "hex:@",
    ]
```

## Producing secrets (`randGen` argument)

A secret often has to adhere to some specific format in order to be processed by the target binary. Since microsurf cannot guess that, it is the end user's job to specify such a function. In our example, the `-K` flag expects a 128bit key specified as a hex string. Since this is a fairly common requirement, it is already implemented in the `microsurf` framework:

```{eval-rst}
.. autoclass:: microsurf.utils.generators.getRandomHexKeyFunction
```

```{note}
The `randGen` parameter takes a __callable__ object. The framework will validate whether it produces sufficiently random output when called.
```

## Selective tracing (`sharedObjects` argument)

To selectively trace shared objects, a list of names can be passed to the `sharedObjects` argument. Note that this only works for dynamic libraries. For example:

```python
sharedObjects = ['libssl', 'libcrypto']
```

will ignore every other shared library (`libc` etc). Only canonical library names are needed, no need to pass the exact file name.

```{note}
The binary specified in `binPath` will always be traced, no need to pass it to the `sharedObjects` parameter.
```

For OpenSSL, the BinaryLoader object would look as follows:

```python
from microsurf.pipeline.Stages import BinaryLoader
from microsurf.utils.generators import getRandomHexKeyFunction

rootfs = 'path-to-rootfs'
binpath = rootfs + "openssl"

opensslArgs = [
    "camellia-128-ecb",
    "-e",
    "-in",
    "input.bin",
    "-out",
    "output.bin",
    "-nosalt",
    "-K",
    "@",

]
sharedObjects = ['libcrypto'] # only trace libcrypto.so

binLoader = BinaryLoader(
    path=binpath, 
    args=opensslArgs, 
    rootfs=rootfs, 
    rndGen=getRandomHexKeyFunction(128),
    sharedObjects=sharedObjects
)

```

## Specifying Detection Modules


There are currently two detection modules which can be used:

1. The secret dependent memory read detection [module](memory.md)
2. The secret dependent control flow detection [module](control-flow.md)

They both take a number of arguments - through most can be left to default values. For further information consult the pages
dedicated to the two modules.

The only required argument is the `binaryLoader`, which is used to pass the previously created `BinaryLoader` object:

```python
from microsurf.pipeline.DetectionModules import CFLeakDetector, DataLeakDetector

binLoader = BinaryLoader(...)
data_leak_detection = DataLeakDetector(binaryLoader=binLoader)
cf_leak_detection = CFLeakDetector(binaryLoader=binLoader)
```

## Executing the analysis

Having created our required detection modules, we are now ready to execute the side channel detection pipeline.
To do so, we can create a `SCDetector` object and pass along the list of detection modules:

```python
from microsurf.pipeline.DetectionModules import CFLeakDetector, DataLeakDetector
from microsurf.pipeline.Stages import BinaryLoader
from microsurf import SCDetector

# Create the binary loader as described before
binLoader = BinaryLoader(...)
data_leak_detection = DataLeakDetector(binaryLoader=binLoader)
cf_leak_detection = CFLeakDetector(binaryLoader=binLoader)

scd = SCDetector(modules=[
        data_leak_detection,
        cf_leak_detection,
    ])

scd.exec()
```

This will search for any data and control flow side channels in the target application.

```{note}
Per default, the `SCDetector` will execute a quick analysis. Key bit dependency estimation is not performed by default.
To 
```

```{warning}
If you know that your target binary has non-deterministic behavior, pass `deterministic=True` when creating the `BinaryLoader`
object. Not doing so might trigger false positives. For more common pitfalls, refer to the [FAQ](faq.md)
```

By default a report will be created in the `reports` directory. If not present, it will be created. If you wish to continue
working and processing results with python, you can access the underlying pandas dataframe like so:

```python
result_dataframe = scd.DF
```

A detailed documentation for all high level modules can be found [here](modules.md).